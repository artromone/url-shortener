
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>circuitbreaker: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">url-shortener/pkg/circuitbreaker/breaker.go (100.0%)</option>
				
				<option value="file1">url-shortener/pkg/ratelimit/limiter.go (77.4%)</option>
				
				<option value="file2">url-shortener/pkg/shortcode/generator.go (85.7%)</option>
				
				<option value="file3">url-shortener/proto/generated/analytics_service/analytics_service.pb.go (0.0%)</option>
				
				<option value="file4">url-shortener/proto/generated/analytics_service/analytics_service_grpc.pb.go (0.0%)</option>
				
				<option value="file5">url-shortener/proto/generated/cache_service/cache_service.pb.go (0.0%)</option>
				
				<option value="file6">url-shortener/proto/generated/cache_service/cache_service_grpc.pb.go (0.0%)</option>
				
				<option value="file7">url-shortener/proto/generated/url_service/url_service.pb.go (0.0%)</option>
				
				<option value="file8">url-shortener/proto/generated/url_service/url_service_grpc.pb.go (0.0%)</option>
				
				<option value="file9">url-shortener/services/analytics-service/main.go (0.0%)</option>
				
				<option value="file10">url-shortener/services/analytics-service/repository/repository.go (0.0%)</option>
				
				<option value="file11">url-shortener/services/analytics-service/service/service.go (0.0%)</option>
				
				<option value="file12">url-shortener/services/analytics-service/worker/worker.go (88.4%)</option>
				
				<option value="file13">url-shortener/services/api-gateway/handlers/handlers.go (0.0%)</option>
				
				<option value="file14">url-shortener/services/api-gateway/main.go (0.0%)</option>
				
				<option value="file15">url-shortener/services/api-gateway/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file16">url-shortener/services/cache-service/cache/cache.go (64.9%)</option>
				
				<option value="file17">url-shortener/services/cache-service/main.go (0.0%)</option>
				
				<option value="file18">url-shortener/services/cache-service/service/service.go (0.0%)</option>
				
				<option value="file19">url-shortener/services/url-service/main.go (0.0%)</option>
				
				<option value="file20">url-shortener/services/url-service/repository/repository.go (0.0%)</option>
				
				<option value="file21">url-shortener/services/url-service/service/service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package circuitbreaker

import (
        "errors"
        "sync"
        "time"
)

type State int

const (
        StateClosed State = iota
        StateOpen
        StateHalfOpen
)

type CircuitBreaker struct {
        maxFailures  int
        resetTimeout time.Duration
        failures     int
        lastFailTime time.Time
        state        State
        mu           sync.RWMutex
}

func New(maxFailures int, resetTimeout time.Duration) *CircuitBreaker <span class="cov6" title="4">{
        return &amp;CircuitBreaker{
                maxFailures:  maxFailures,
                resetTimeout: resetTimeout,
                state:        StateClosed,
        }
}</span>

func (cb *CircuitBreaker) Call(fn func() error) error <span class="cov10" title="10">{
        cb.mu.Lock()

        if cb.state == StateOpen </span><span class="cov3" title="2">{
                if time.Since(cb.lastFailTime) &gt; cb.resetTimeout </span><span class="cov1" title="1">{
                        cb.state = StateHalfOpen
                }</span> else<span class="cov1" title="1"> {
                        cb.mu.Unlock()
                        return errors.New("circuit breaker is open")
                }</span>
        }

        <span class="cov9" title="9">cb.mu.Unlock()

        err := fn()

        cb.mu.Lock()
        defer cb.mu.Unlock()

        if err != nil </span><span class="cov8" title="6">{
                cb.failures++
                cb.lastFailTime = time.Now()

                if cb.failures &gt;= cb.maxFailures </span><span class="cov3" title="2">{
                        cb.state = StateOpen
                }</span>
                <span class="cov8" title="6">return err</span>
        }

        <span class="cov5" title="3">if cb.state == StateHalfOpen </span><span class="cov1" title="1">{
                cb.state = StateClosed
        }</span>
        <span class="cov5" title="3">cb.failures = 0
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ratelimit

import (
        "sync"
        "time"
)

type Limiter struct {
        tokens map[string]*bucket
        mu     sync.RWMutex
        rate   int
        per    time.Duration
}

type bucket struct {
        tokens   int
        lastSeen time.Time
}

func New(rate int, per time.Duration) *Limiter <span class="cov3" title="4">{
        l := &amp;Limiter{
                tokens: make(map[string]*bucket),
                rate:   rate,
                per:    per,
        }

        go l.cleanup()
        return l
}</span>

func (l *Limiter) Allow(key string) bool <span class="cov10" title="217">{
        l.mu.Lock()
        defer l.mu.Unlock()

        now := time.Now()
        b, exists := l.tokens[key]

        if !exists </span><span class="cov3" title="5">{
                l.tokens[key] = &amp;bucket{
                        tokens:   l.rate - 1,
                        lastSeen: now,
                }
                return true
        }</span>

        <span class="cov9" title="212">elapsed := now.Sub(b.lastSeen)
        tokensToAdd := int(elapsed / l.per)

        if tokensToAdd &gt; 0 </span><span class="cov1" title="1">{
                b.tokens = min(l.rate, b.tokens+tokensToAdd)
                b.lastSeen = now
        }</span>

        <span class="cov9" title="212">if b.tokens &gt; 0 </span><span class="cov8" title="108">{
                b.tokens--
                return true
        }</span>

        <span class="cov8" title="104">return false</span>
}

func (l *Limiter) cleanup() <span class="cov3" title="4">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                l.mu.Lock()
                now := time.Now()
                for key, b := range l.tokens </span><span class="cov0" title="0">{
                        if now.Sub(b.lastSeen) &gt; 5*time.Minute </span><span class="cov0" title="0">{
                                delete(l.tokens, key)
                        }</span>
                }
                <span class="cov0" title="0">l.mu.Unlock()</span>
        }
}

func min(a, b int) int <span class="cov1" title="1">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov1" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package shortcode

import (
        "crypto/rand"
        "math/big"
)

const (
        charset         = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        shortCodeLength = 7
)

func Generate() (string, error) <span class="cov8" title="11001">{
        result := make([]byte, shortCodeLength)
        for i := range result </span><span class="cov10" title="77007">{
                num, err := rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov10" title="77007">result[i] = charset[num.Int64()]</span>
        }
        <span class="cov8" title="11001">return string(result), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.32.1
// source: proto/analytics_service.proto

package analytics_service

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ClickEvent struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortCode     string                 `protobuf:"bytes,1,opt,name=short_code,json=shortCode,proto3" json:"short_code,omitempty"`
        IpAddress     string                 `protobuf:"bytes,2,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
        UserAgent     string                 `protobuf:"bytes,3,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty"`
        Referer       string                 `protobuf:"bytes,4,opt,name=referer,proto3" json:"referer,omitempty"`
        Country       string                 `protobuf:"bytes,5,opt,name=country,proto3" json:"country,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ClickEvent) Reset() <span class="cov0" title="0">{
        *x = ClickEvent{}
        mi := &amp;file_proto_analytics_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ClickEvent) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClickEvent) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClickEvent) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_analytics_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClickEvent.ProtoReflect.Descriptor instead.
func (*ClickEvent) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_analytics_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ClickEvent) GetShortCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClickEvent) GetIpAddress() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IpAddress
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClickEvent) GetUserAgent() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserAgent
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClickEvent) GetReferer() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Referer
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ClickEvent) GetCountry() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Country
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ClickResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *ClickResponse) Reset() <span class="cov0" title="0">{
        *x = ClickResponse{}
        mi := &amp;file_proto_analytics_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *ClickResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ClickResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ClickResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_analytics_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ClickResponse.ProtoReflect.Descriptor instead.
func (*ClickResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_analytics_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ClickResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type StatsRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortCode     string                 `protobuf:"bytes,1,opt,name=short_code,json=shortCode,proto3" json:"short_code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *StatsRequest) Reset() <span class="cov0" title="0">{
        *x = StatsRequest{}
        mi := &amp;file_proto_analytics_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_analytics_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsRequest.ProtoReflect.Descriptor instead.
func (*StatsRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_analytics_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *StatsRequest) GetShortCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StatsResponse struct {
        state          protoimpl.MessageState `protogen:"open.v1"`
        TotalClicks    int64                  `protobuf:"varint,1,opt,name=total_clicks,json=totalClicks,proto3" json:"total_clicks,omitempty"`
        UniqueVisitors int64                  `protobuf:"varint,2,opt,name=unique_visitors,json=uniqueVisitors,proto3" json:"unique_visitors,omitempty"`
        LastClickedAt  string                 `protobuf:"bytes,3,opt,name=last_clicked_at,json=lastClickedAt,proto3" json:"last_clicked_at,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *StatsResponse) Reset() <span class="cov0" title="0">{
        *x = StatsResponse{}
        mi := &amp;file_proto_analytics_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *StatsResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StatsResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StatsResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_analytics_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StatsResponse.ProtoReflect.Descriptor instead.
func (*StatsResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_analytics_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *StatsResponse) GetTotalClicks() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TotalClicks
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetUniqueVisitors() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UniqueVisitors
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *StatsResponse) GetLastClickedAt() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastClickedAt
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_proto_analytics_service_proto protoreflect.FileDescriptor

var file_proto_analytics_service_proto_rawDesc = string([]byte{
        0x0a, 0x1d, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63,
        0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x11, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x22, 0x9d, 0x01, 0x0a, 0x0a, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x45, 0x76, 0x65, 0x6e,
        0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x64, 0x65,
        0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x69, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12,
        0x1d, 0x0a, 0x0a, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x09, 0x75, 0x73, 0x65, 0x72, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x12, 0x18,
        0x0a, 0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x75, 0x6e,
        0x74, 0x72, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x75, 0x6e, 0x74,
        0x72, 0x79, 0x22, 0x29, 0x0a, 0x0d, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x2d, 0x0a,
        0x0c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
        0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x83, 0x01, 0x0a,
        0x0d, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x21,
        0x0a, 0x0c, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x73, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x43, 0x6c, 0x69, 0x63, 0x6b,
        0x73, 0x12, 0x27, 0x0a, 0x0f, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x5f, 0x76, 0x69, 0x73, 0x69,
        0x74, 0x6f, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0e, 0x75, 0x6e, 0x69, 0x71,
        0x75, 0x65, 0x56, 0x69, 0x73, 0x69, 0x74, 0x6f, 0x72, 0x73, 0x12, 0x26, 0x0a, 0x0f, 0x6c, 0x61,
        0x73, 0x74, 0x5f, 0x63, 0x6c, 0x69, 0x63, 0x6b, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0d, 0x6c, 0x61, 0x73, 0x74, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x65, 0x64,
        0x41, 0x74, 0x32, 0xb6, 0x01, 0x0a, 0x10, 0x41, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4e, 0x0a, 0x0b, 0x52, 0x65, 0x63, 0x6f, 0x72,
        0x64, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x12, 0x1d, 0x2e, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69,
        0x63, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x6c, 0x69, 0x63, 0x6b,
        0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x20, 0x2e, 0x61, 0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63,
        0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x6c, 0x69, 0x63, 0x6b, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x52, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x53, 0x74,
        0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x1f, 0x2e, 0x61, 0x6e, 0x61, 0x6c, 0x79,
        0x74, 0x69, 0x63, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x53, 0x74, 0x61,
        0x74, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x61, 0x6e, 0x61, 0x6c,
        0x79, 0x74, 0x69, 0x63, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x53, 0x74,
        0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x23, 0x5a, 0x21, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x2f, 0x61,
        0x6e, 0x61, 0x6c, 0x79, 0x74, 0x69, 0x63, 0x73, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_proto_analytics_service_proto_rawDescOnce sync.Once
        file_proto_analytics_service_proto_rawDescData []byte
)

func file_proto_analytics_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_analytics_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_analytics_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_analytics_service_proto_rawDesc), len(file_proto_analytics_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_analytics_service_proto_rawDescData</span>
}

var file_proto_analytics_service_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_proto_analytics_service_proto_goTypes = []any{
        (*ClickEvent)(nil),    // 0: analytics_service.ClickEvent
        (*ClickResponse)(nil), // 1: analytics_service.ClickResponse
        (*StatsRequest)(nil),  // 2: analytics_service.StatsRequest
        (*StatsResponse)(nil), // 3: analytics_service.StatsResponse
}
var file_proto_analytics_service_proto_depIdxs = []int32{
        0, // 0: analytics_service.AnalyticsService.RecordClick:input_type -&gt; analytics_service.ClickEvent
        2, // 1: analytics_service.AnalyticsService.GetStatistics:input_type -&gt; analytics_service.StatsRequest
        1, // 2: analytics_service.AnalyticsService.RecordClick:output_type -&gt; analytics_service.ClickResponse
        3, // 3: analytics_service.AnalyticsService.GetStatistics:output_type -&gt; analytics_service.StatsResponse
        2, // [2:4] is the sub-list for method output_type
        0, // [0:2] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_analytics_service_proto_init() }</span>
func file_proto_analytics_service_proto_init() <span class="cov0" title="0">{
        if File_proto_analytics_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_analytics_service_proto_rawDesc), len(file_proto_analytics_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_analytics_service_proto_goTypes,
                DependencyIndexes: file_proto_analytics_service_proto_depIdxs,
                MessageInfos:      file_proto_analytics_service_proto_msgTypes,
        }.Build()
        File_proto_analytics_service_proto = out.File
        file_proto_analytics_service_proto_goTypes = nil
        file_proto_analytics_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: proto/analytics_service.proto

package analytics_service

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        AnalyticsService_RecordClick_FullMethodName   = "/analytics_service.AnalyticsService/RecordClick"
        AnalyticsService_GetStatistics_FullMethodName = "/analytics_service.AnalyticsService/GetStatistics"
)

// AnalyticsServiceClient is the client API for AnalyticsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnalyticsServiceClient interface {
        RecordClick(ctx context.Context, in *ClickEvent, opts ...grpc.CallOption) (*ClickResponse, error)
        GetStatistics(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error)
}

type analyticsServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewAnalyticsServiceClient(cc grpc.ClientConnInterface) AnalyticsServiceClient <span class="cov0" title="0">{
        return &amp;analyticsServiceClient{cc}
}</span>

func (c *analyticsServiceClient) RecordClick(ctx context.Context, in *ClickEvent, opts ...grpc.CallOption) (*ClickResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(ClickResponse)
        err := c.cc.Invoke(ctx, AnalyticsService_RecordClick_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *analyticsServiceClient) GetStatistics(ctx context.Context, in *StatsRequest, opts ...grpc.CallOption) (*StatsResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(StatsResponse)
        err := c.cc.Invoke(ctx, AnalyticsService_GetStatistics_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// AnalyticsServiceServer is the server API for AnalyticsService service.
// All implementations must embed UnimplementedAnalyticsServiceServer
// for forward compatibility.
type AnalyticsServiceServer interface {
        RecordClick(context.Context, *ClickEvent) (*ClickResponse, error)
        GetStatistics(context.Context, *StatsRequest) (*StatsResponse, error)
        mustEmbedUnimplementedAnalyticsServiceServer()
}

// UnimplementedAnalyticsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAnalyticsServiceServer struct{}

func (UnimplementedAnalyticsServiceServer) RecordClick(context.Context, *ClickEvent) (*ClickResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method RecordClick not implemented")
}</span>
func (UnimplementedAnalyticsServiceServer) GetStatistics(context.Context, *StatsRequest) (*StatsResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetStatistics not implemented")
}</span>
func (UnimplementedAnalyticsServiceServer) mustEmbedUnimplementedAnalyticsServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedAnalyticsServiceServer) testEmbeddedByValue()                          {<span class="cov0" title="0">}</span>

// UnsafeAnalyticsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnalyticsServiceServer will
// result in compilation errors.
type UnsafeAnalyticsServiceServer interface {
        mustEmbedUnimplementedAnalyticsServiceServer()
}

func RegisterAnalyticsServiceServer(s grpc.ServiceRegistrar, srv AnalyticsServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedAnalyticsServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;AnalyticsService_ServiceDesc, srv)</span>
}

func _AnalyticsService_RecordClick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(ClickEvent)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AnalyticsServiceServer).RecordClick(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AnalyticsService_RecordClick_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AnalyticsServiceServer).RecordClick(ctx, req.(*ClickEvent))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _AnalyticsService_GetStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(StatsRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(AnalyticsServiceServer).GetStatistics(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: AnalyticsService_GetStatistics_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(AnalyticsServiceServer).GetStatistics(ctx, req.(*StatsRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// AnalyticsService_ServiceDesc is the grpc.ServiceDesc for AnalyticsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AnalyticsService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "analytics_service.AnalyticsService",
        HandlerType: (*AnalyticsServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "RecordClick",
                        Handler:    _AnalyticsService_RecordClick_Handler,
                },
                {
                        MethodName: "GetStatistics",
                        Handler:    _AnalyticsService_GetStatistics_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/analytics_service.proto",
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.32.1
// source: proto/cache_service.proto

package cache_service

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CacheGetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CacheGetRequest) Reset() <span class="cov0" title="0">{
        *x = CacheGetRequest{}
        mi := &amp;file_proto_cache_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CacheGetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CacheGetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CacheGetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cache_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CacheGetRequest.ProtoReflect.Descriptor instead.
func (*CacheGetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cache_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CacheGetRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CacheGetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Value         string                 `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CacheGetResponse) Reset() <span class="cov0" title="0">{
        *x = CacheGetResponse{}
        mi := &amp;file_proto_cache_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CacheGetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CacheGetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CacheGetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cache_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CacheGetResponse.ProtoReflect.Descriptor instead.
func (*CacheGetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cache_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CacheGetResponse) GetValue() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CacheGetResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CacheSetRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
        TtlSeconds    int32                  `protobuf:"varint,3,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CacheSetRequest) Reset() <span class="cov0" title="0">{
        *x = CacheSetRequest{}
        mi := &amp;file_proto_cache_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CacheSetRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CacheSetRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CacheSetRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cache_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CacheSetRequest.ProtoReflect.Descriptor instead.
func (*CacheSetRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cache_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *CacheSetRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CacheSetRequest) GetValue() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CacheSetRequest) GetTtlSeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TtlSeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CacheSetResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CacheSetResponse) Reset() <span class="cov0" title="0">{
        *x = CacheSetResponse{}
        mi := &amp;file_proto_cache_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CacheSetResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CacheSetResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CacheSetResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cache_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CacheSetResponse.ProtoReflect.Descriptor instead.
func (*CacheSetResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cache_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *CacheSetResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

type CacheDeleteRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CacheDeleteRequest) Reset() <span class="cov0" title="0">{
        *x = CacheDeleteRequest{}
        mi := &amp;file_proto_cache_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CacheDeleteRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CacheDeleteRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CacheDeleteRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cache_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CacheDeleteRequest.ProtoReflect.Descriptor instead.
func (*CacheDeleteRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cache_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CacheDeleteRequest) GetKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Key
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type CacheDeleteResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CacheDeleteResponse) Reset() <span class="cov0" title="0">{
        *x = CacheDeleteResponse{}
        mi := &amp;file_proto_cache_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CacheDeleteResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CacheDeleteResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CacheDeleteResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_cache_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CacheDeleteResponse.ProtoReflect.Descriptor instead.
func (*CacheDeleteResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_cache_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *CacheDeleteResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_proto_cache_service_proto protoreflect.FileDescriptor

var file_proto_cache_service_proto_rawDesc = string([]byte{
        0x0a, 0x19, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x63, 0x61, 0x63,
        0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x22, 0x23, 0x0a, 0x0f, 0x43, 0x61,
        0x63, 0x68, 0x65, 0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x22,
        0x3e, 0x0a, 0x10, 0x43, 0x61, 0x63, 0x68, 0x65, 0x47, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x6f, 0x75,
        0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x22,
        0x5a, 0x0a, 0x0f, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x74, 0x74,
        0x6c, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x0a, 0x74, 0x74, 0x6c, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x22, 0x2c, 0x0a, 0x10, 0x43,
        0x61, 0x63, 0x68, 0x65, 0x53, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x22, 0x26, 0x0a, 0x12, 0x43, 0x61, 0x63,
        0x68, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
        0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65,
        0x79, 0x22, 0x2f, 0x0a, 0x13, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63,
        0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65,
        0x73, 0x73, 0x32, 0xef, 0x01, 0x0a, 0x0c, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x12, 0x46, 0x0a, 0x03, 0x47, 0x65, 0x74, 0x12, 0x1e, 0x2e, 0x63, 0x61, 0x63,
        0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65,
        0x47, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x63, 0x61, 0x63,
        0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65,
        0x47, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x46, 0x0a, 0x03, 0x53,
        0x65, 0x74, 0x12, 0x1e, 0x2e, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x65, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x4f, 0x0a, 0x06, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x21, 0x2e,
        0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x61,
        0x63, 0x68, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x22, 0x2e, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x2e, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x42, 0x1f, 0x5a, 0x1d, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x65,
        0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x2f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_proto_cache_service_proto_rawDescOnce sync.Once
        file_proto_cache_service_proto_rawDescData []byte
)

func file_proto_cache_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_cache_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_cache_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_cache_service_proto_rawDesc), len(file_proto_cache_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_cache_service_proto_rawDescData</span>
}

var file_proto_cache_service_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_proto_cache_service_proto_goTypes = []any{
        (*CacheGetRequest)(nil),     // 0: cache_service.CacheGetRequest
        (*CacheGetResponse)(nil),    // 1: cache_service.CacheGetResponse
        (*CacheSetRequest)(nil),     // 2: cache_service.CacheSetRequest
        (*CacheSetResponse)(nil),    // 3: cache_service.CacheSetResponse
        (*CacheDeleteRequest)(nil),  // 4: cache_service.CacheDeleteRequest
        (*CacheDeleteResponse)(nil), // 5: cache_service.CacheDeleteResponse
}
var file_proto_cache_service_proto_depIdxs = []int32{
        0, // 0: cache_service.CacheService.Get:input_type -&gt; cache_service.CacheGetRequest
        2, // 1: cache_service.CacheService.Set:input_type -&gt; cache_service.CacheSetRequest
        4, // 2: cache_service.CacheService.Delete:input_type -&gt; cache_service.CacheDeleteRequest
        1, // 3: cache_service.CacheService.Get:output_type -&gt; cache_service.CacheGetResponse
        3, // 4: cache_service.CacheService.Set:output_type -&gt; cache_service.CacheSetResponse
        5, // 5: cache_service.CacheService.Delete:output_type -&gt; cache_service.CacheDeleteResponse
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_cache_service_proto_init() }</span>
func file_proto_cache_service_proto_init() <span class="cov0" title="0">{
        if File_proto_cache_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_cache_service_proto_rawDesc), len(file_proto_cache_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_cache_service_proto_goTypes,
                DependencyIndexes: file_proto_cache_service_proto_depIdxs,
                MessageInfos:      file_proto_cache_service_proto_msgTypes,
        }.Build()
        File_proto_cache_service_proto = out.File
        file_proto_cache_service_proto_goTypes = nil
        file_proto_cache_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: proto/cache_service.proto

package cache_service

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        CacheService_Get_FullMethodName    = "/cache_service.CacheService/Get"
        CacheService_Set_FullMethodName    = "/cache_service.CacheService/Set"
        CacheService_Delete_FullMethodName = "/cache_service.CacheService/Delete"
)

// CacheServiceClient is the client API for CacheService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CacheServiceClient interface {
        Get(ctx context.Context, in *CacheGetRequest, opts ...grpc.CallOption) (*CacheGetResponse, error)
        Set(ctx context.Context, in *CacheSetRequest, opts ...grpc.CallOption) (*CacheSetResponse, error)
        Delete(ctx context.Context, in *CacheDeleteRequest, opts ...grpc.CallOption) (*CacheDeleteResponse, error)
}

type cacheServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewCacheServiceClient(cc grpc.ClientConnInterface) CacheServiceClient <span class="cov0" title="0">{
        return &amp;cacheServiceClient{cc}
}</span>

func (c *cacheServiceClient) Get(ctx context.Context, in *CacheGetRequest, opts ...grpc.CallOption) (*CacheGetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CacheGetResponse)
        err := c.cc.Invoke(ctx, CacheService_Get_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *cacheServiceClient) Set(ctx context.Context, in *CacheSetRequest, opts ...grpc.CallOption) (*CacheSetResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CacheSetResponse)
        err := c.cc.Invoke(ctx, CacheService_Set_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *cacheServiceClient) Delete(ctx context.Context, in *CacheDeleteRequest, opts ...grpc.CallOption) (*CacheDeleteResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CacheDeleteResponse)
        err := c.cc.Invoke(ctx, CacheService_Delete_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// CacheServiceServer is the server API for CacheService service.
// All implementations must embed UnimplementedCacheServiceServer
// for forward compatibility.
type CacheServiceServer interface {
        Get(context.Context, *CacheGetRequest) (*CacheGetResponse, error)
        Set(context.Context, *CacheSetRequest) (*CacheSetResponse, error)
        Delete(context.Context, *CacheDeleteRequest) (*CacheDeleteResponse, error)
        mustEmbedUnimplementedCacheServiceServer()
}

// UnimplementedCacheServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCacheServiceServer struct{}

func (UnimplementedCacheServiceServer) Get(context.Context, *CacheGetRequest) (*CacheGetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}</span>
func (UnimplementedCacheServiceServer) Set(context.Context, *CacheSetRequest) (*CacheSetResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}</span>
func (UnimplementedCacheServiceServer) Delete(context.Context, *CacheDeleteRequest) (*CacheDeleteResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}</span>
func (UnimplementedCacheServiceServer) mustEmbedUnimplementedCacheServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedCacheServiceServer) testEmbeddedByValue()                      {<span class="cov0" title="0">}</span>

// UnsafeCacheServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CacheServiceServer will
// result in compilation errors.
type UnsafeCacheServiceServer interface {
        mustEmbedUnimplementedCacheServiceServer()
}

func RegisterCacheServiceServer(s grpc.ServiceRegistrar, srv CacheServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedCacheServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;CacheService_ServiceDesc, srv)</span>
}

func _CacheService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CacheGetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CacheServiceServer).Get(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CacheService_Get_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CacheServiceServer).Get(ctx, req.(*CacheGetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _CacheService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CacheSetRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CacheServiceServer).Set(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CacheService_Set_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CacheServiceServer).Set(ctx, req.(*CacheSetRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _CacheService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CacheDeleteRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(CacheServiceServer).Delete(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: CacheService_Delete_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(CacheServiceServer).Delete(ctx, req.(*CacheDeleteRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// CacheService_ServiceDesc is the grpc.ServiceDesc for CacheService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CacheService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "cache_service.CacheService",
        HandlerType: (*CacheServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Get",
                        Handler:    _CacheService_Get_Handler,
                },
                {
                        MethodName: "Set",
                        Handler:    _CacheService_Set_Handler,
                },
                {
                        MethodName: "Delete",
                        Handler:    _CacheService_Delete_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/cache_service.proto",
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.5
//         protoc        v6.32.1
// source: proto/url_service.proto

package url_service

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CreateURLRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OriginalUrl   string                 `protobuf:"bytes,1,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        UserId        string                 `protobuf:"bytes,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
        ExpiresInDays int64                  `protobuf:"varint,3,opt,name=expires_in_days,json=expiresInDays,proto3" json:"expires_in_days,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateURLRequest) Reset() <span class="cov0" title="0">{
        *x = CreateURLRequest{}
        mi := &amp;file_proto_url_service_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateURLRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateURLRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateURLRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_url_service_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateURLRequest.ProtoReflect.Descriptor instead.
func (*CreateURLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_url_service_proto_rawDescGZIP(), []int{0}
}</span>

func (x *CreateURLRequest) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateURLRequest) GetUserId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateURLRequest) GetExpiresInDays() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpiresInDays
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type CreateURLResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortCode     string                 `protobuf:"bytes,1,opt,name=short_code,json=shortCode,proto3" json:"short_code,omitempty"`
        ShortUrl      string                 `protobuf:"bytes,2,opt,name=short_url,json=shortUrl,proto3" json:"short_url,omitempty"`
        Success       bool                   `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
        Error         string                 `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CreateURLResponse) Reset() <span class="cov0" title="0">{
        *x = CreateURLResponse{}
        mi := &amp;file_proto_url_service_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CreateURLResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CreateURLResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CreateURLResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_url_service_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CreateURLResponse.ProtoReflect.Descriptor instead.
func (*CreateURLResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_url_service_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CreateURLResponse) GetShortCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateURLResponse) GetShortUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *CreateURLResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *CreateURLResponse) GetError() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Error
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetURLRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortCode     string                 `protobuf:"bytes,1,opt,name=short_code,json=shortCode,proto3" json:"short_code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetURLRequest) Reset() <span class="cov0" title="0">{
        *x = GetURLRequest{}
        mi := &amp;file_proto_url_service_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetURLRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetURLRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetURLRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_url_service_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetURLRequest.ProtoReflect.Descriptor instead.
func (*GetURLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_url_service_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetURLRequest) GetShortCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type GetURLResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        OriginalUrl   string                 `protobuf:"bytes,1,opt,name=original_url,json=originalUrl,proto3" json:"original_url,omitempty"`
        Found         bool                   `protobuf:"varint,2,opt,name=found,proto3" json:"found,omitempty"`
        IsActive      bool                   `protobuf:"varint,3,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *GetURLResponse) Reset() <span class="cov0" title="0">{
        *x = GetURLResponse{}
        mi := &amp;file_proto_url_service_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *GetURLResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetURLResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetURLResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_url_service_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetURLResponse.ProtoReflect.Descriptor instead.
func (*GetURLResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_url_service_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetURLResponse) GetOriginalUrl() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalUrl
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetURLResponse) GetFound() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Found
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetURLResponse) GetIsActive() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IsActive
        }</span>
        <span class="cov0" title="0">return false</span>
}

type DeleteURLRequest struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        ShortCode     string                 `protobuf:"bytes,1,opt,name=short_code,json=shortCode,proto3" json:"short_code,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteURLRequest) Reset() <span class="cov0" title="0">{
        *x = DeleteURLRequest{}
        mi := &amp;file_proto_url_service_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteURLRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteURLRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteURLRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_url_service_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteURLRequest.ProtoReflect.Descriptor instead.
func (*DeleteURLRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_url_service_proto_rawDescGZIP(), []int{4}
}</span>

func (x *DeleteURLRequest) GetShortCode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ShortCode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type DeleteURLResponse struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Success       bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeleteURLResponse) Reset() <span class="cov0" title="0">{
        *x = DeleteURLResponse{}
        mi := &amp;file_proto_url_service_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeleteURLResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeleteURLResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeleteURLResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_url_service_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeleteURLResponse.ProtoReflect.Descriptor instead.
func (*DeleteURLResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_url_service_proto_rawDescGZIP(), []int{5}
}</span>

func (x *DeleteURLResponse) GetSuccess() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Success
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_proto_url_service_proto protoreflect.FileDescriptor

var file_proto_url_service_proto_rawDesc = string([]byte{
        0x0a, 0x17, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x75, 0x72, 0x6c, 0x5f, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x75, 0x72, 0x6c, 0x5f, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x22, 0x76, 0x0a, 0x10, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x55, 0x52, 0x4c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x72,
        0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0b, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x55, 0x72, 0x6c, 0x12, 0x17, 0x0a,
        0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
        0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x26, 0x0a, 0x0f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65,
        0x73, 0x5f, 0x69, 0x6e, 0x5f, 0x64, 0x61, 0x79, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52,
        0x0d, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x73, 0x49, 0x6e, 0x44, 0x61, 0x79, 0x73, 0x22, 0x7f,
        0x0a, 0x11, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x64,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x43, 0x6f,
        0x64, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x75, 0x72, 0x6c, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x55, 0x72, 0x6c, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x65, 0x72, 0x72,
        0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x22,
        0x2e, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x1d, 0x0a, 0x0a, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x22,
        0x66, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x12, 0x21, 0x0a, 0x0c, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x75, 0x72,
        0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61,
        0x6c, 0x55, 0x72, 0x6c, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x05, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73,
        0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69,
        0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x22, 0x31, 0x0a, 0x10, 0x44, 0x65, 0x6c, 0x65, 0x74,
        0x65, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x73,
        0x68, 0x6f, 0x72, 0x74, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x09, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x43, 0x6f, 0x64, 0x65, 0x22, 0x2d, 0x0a, 0x11, 0x44, 0x65,
        0x6c, 0x65, 0x74, 0x65, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x18, 0x0a, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08,
        0x52, 0x07, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x32, 0xf4, 0x01, 0x0a, 0x0a, 0x55, 0x52,
        0x4c, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x4f, 0x0a, 0x0e, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x53, 0x68, 0x6f, 0x72, 0x74, 0x55, 0x52, 0x4c, 0x12, 0x1d, 0x2e, 0x75, 0x72, 0x6c,
        0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55,
        0x52, 0x4c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x75, 0x72, 0x6c, 0x5f,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x52,
        0x4c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x49, 0x0a, 0x0e, 0x47, 0x65, 0x74,
        0x4f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x55, 0x52, 0x4c, 0x12, 0x1a, 0x2e, 0x75, 0x72,
        0x6c, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x52, 0x4c,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1b, 0x2e, 0x75, 0x72, 0x6c, 0x5f, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x73, 0x70,
        0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4a, 0x0a, 0x09, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x52,
        0x4c, 0x12, 0x1d, 0x2e, 0x75, 0x72, 0x6c, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e,
        0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x1a, 0x1e, 0x2e, 0x75, 0x72, 0x6c, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x44,
        0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x52, 0x4c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x42, 0x1d, 0x5a, 0x1b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61,
        0x74, 0x65, 0x64, 0x2f, 0x75, 0x72, 0x6c, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x62,
        0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
        file_proto_url_service_proto_rawDescOnce sync.Once
        file_proto_url_service_proto_rawDescData []byte
)

func file_proto_url_service_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_url_service_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_url_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_proto_url_service_proto_rawDesc), len(file_proto_url_service_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_proto_url_service_proto_rawDescData</span>
}

var file_proto_url_service_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_proto_url_service_proto_goTypes = []any{
        (*CreateURLRequest)(nil),  // 0: url_service.CreateURLRequest
        (*CreateURLResponse)(nil), // 1: url_service.CreateURLResponse
        (*GetURLRequest)(nil),     // 2: url_service.GetURLRequest
        (*GetURLResponse)(nil),    // 3: url_service.GetURLResponse
        (*DeleteURLRequest)(nil),  // 4: url_service.DeleteURLRequest
        (*DeleteURLResponse)(nil), // 5: url_service.DeleteURLResponse
}
var file_proto_url_service_proto_depIdxs = []int32{
        0, // 0: url_service.URLService.CreateShortURL:input_type -&gt; url_service.CreateURLRequest
        2, // 1: url_service.URLService.GetOriginalURL:input_type -&gt; url_service.GetURLRequest
        4, // 2: url_service.URLService.DeleteURL:input_type -&gt; url_service.DeleteURLRequest
        1, // 3: url_service.URLService.CreateShortURL:output_type -&gt; url_service.CreateURLResponse
        3, // 4: url_service.URLService.GetOriginalURL:output_type -&gt; url_service.GetURLResponse
        5, // 5: url_service.URLService.DeleteURL:output_type -&gt; url_service.DeleteURLResponse
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_proto_url_service_proto_init() }</span>
func file_proto_url_service_proto_init() <span class="cov0" title="0">{
        if File_proto_url_service_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_proto_url_service_proto_rawDesc), len(file_proto_url_service_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_url_service_proto_goTypes,
                DependencyIndexes: file_proto_url_service_proto_depIdxs,
                MessageInfos:      file_proto_url_service_proto_msgTypes,
        }.Build()
        File_proto_url_service_proto = out.File
        file_proto_url_service_proto_goTypes = nil
        file_proto_url_service_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.32.1
// source: proto/url_service.proto

package url_service

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        URLService_CreateShortURL_FullMethodName = "/url_service.URLService/CreateShortURL"
        URLService_GetOriginalURL_FullMethodName = "/url_service.URLService/GetOriginalURL"
        URLService_DeleteURL_FullMethodName      = "/url_service.URLService/DeleteURL"
)

// URLServiceClient is the client API for URLService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type URLServiceClient interface {
        CreateShortURL(ctx context.Context, in *CreateURLRequest, opts ...grpc.CallOption) (*CreateURLResponse, error)
        GetOriginalURL(ctx context.Context, in *GetURLRequest, opts ...grpc.CallOption) (*GetURLResponse, error)
        DeleteURL(ctx context.Context, in *DeleteURLRequest, opts ...grpc.CallOption) (*DeleteURLResponse, error)
}

type uRLServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewURLServiceClient(cc grpc.ClientConnInterface) URLServiceClient <span class="cov0" title="0">{
        return &amp;uRLServiceClient{cc}
}</span>

func (c *uRLServiceClient) CreateShortURL(ctx context.Context, in *CreateURLRequest, opts ...grpc.CallOption) (*CreateURLResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(CreateURLResponse)
        err := c.cc.Invoke(ctx, URLService_CreateShortURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *uRLServiceClient) GetOriginalURL(ctx context.Context, in *GetURLRequest, opts ...grpc.CallOption) (*GetURLResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(GetURLResponse)
        err := c.cc.Invoke(ctx, URLService_GetOriginalURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *uRLServiceClient) DeleteURL(ctx context.Context, in *DeleteURLRequest, opts ...grpc.CallOption) (*DeleteURLResponse, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(DeleteURLResponse)
        err := c.cc.Invoke(ctx, URLService_DeleteURL_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// URLServiceServer is the server API for URLService service.
// All implementations must embed UnimplementedURLServiceServer
// for forward compatibility.
type URLServiceServer interface {
        CreateShortURL(context.Context, *CreateURLRequest) (*CreateURLResponse, error)
        GetOriginalURL(context.Context, *GetURLRequest) (*GetURLResponse, error)
        DeleteURL(context.Context, *DeleteURLRequest) (*DeleteURLResponse, error)
        mustEmbedUnimplementedURLServiceServer()
}

// UnimplementedURLServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedURLServiceServer struct{}

func (UnimplementedURLServiceServer) CreateShortURL(context.Context, *CreateURLRequest) (*CreateURLResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateShortURL not implemented")
}</span>
func (UnimplementedURLServiceServer) GetOriginalURL(context.Context, *GetURLRequest) (*GetURLResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOriginalURL not implemented")
}</span>
func (UnimplementedURLServiceServer) DeleteURL(context.Context, *DeleteURLRequest) (*DeleteURLResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method DeleteURL not implemented")
}</span>
func (UnimplementedURLServiceServer) mustEmbedUnimplementedURLServiceServer() {<span class="cov0" title="0">}</span>
func (UnimplementedURLServiceServer) testEmbeddedByValue()                    {<span class="cov0" title="0">}</span>

// UnsafeURLServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to URLServiceServer will
// result in compilation errors.
type UnsafeURLServiceServer interface {
        mustEmbedUnimplementedURLServiceServer()
}

func RegisterURLServiceServer(s grpc.ServiceRegistrar, srv URLServiceServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedURLServiceServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;URLService_ServiceDesc, srv)</span>
}

func _URLService_CreateShortURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(CreateURLRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(URLServiceServer).CreateShortURL(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: URLService_CreateShortURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(URLServiceServer).CreateShortURL(ctx, req.(*CreateURLRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _URLService_GetOriginalURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetURLRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(URLServiceServer).GetOriginalURL(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: URLService_GetOriginalURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(URLServiceServer).GetOriginalURL(ctx, req.(*GetURLRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _URLService_DeleteURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(DeleteURLRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(URLServiceServer).DeleteURL(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: URLService_DeleteURL_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(URLServiceServer).DeleteURL(ctx, req.(*DeleteURLRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// URLService_ServiceDesc is the grpc.ServiceDesc for URLService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var URLService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "url_service.URLService",
        HandlerType: (*URLServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateShortURL",
                        Handler:    _URLService_CreateShortURL_Handler,
                },
                {
                        MethodName: "GetOriginalURL",
                        Handler:    _URLService_GetOriginalURL_Handler,
                },
                {
                        MethodName: "DeleteURL",
                        Handler:    _URLService_DeleteURL_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "proto/url_service.proto",
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "database/sql"
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"

        "url-shortener/services/analytics-service/repository"
        "url-shortener/services/analytics-service/service"
        "url-shortener/services/analytics-service/worker"

        _ "github.com/lib/pq"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        pb "url-shortener/proto/generated/analytics_service"
)

func main() <span class="cov0" title="0">{
        dbURL := os.Getenv("DATABASE_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                log.Fatal("DATABASE_URL not set")
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)

        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to ping database: %v", err)
        }</span>

        <span class="cov0" title="0">repo := repository.New(db)

        pool := worker.New(10, 1000, repo)
        pool.Start()

        svc := service.New(pool, repo)

        lis, err := net.Listen("tcp", ":50052")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        pb.RegisterAnalyticsServiceServer(grpcServer, svc)
        reflection.Register(grpcServer)

        go func() </span><span class="cov0" title="0">{
                log.Println("Analytics Service listening on :50052")
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to serve: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("Shutting down Analytics Service...")
        pool.Stop()
        grpcServer.GracefulStop()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package repository

import (
        "database/sql"
        "time"
        "url-shortener/services/analytics-service/models"

        sq "github.com/Masterminds/squirrel"
)

type Repository struct {
        db *sql.DB
        qb sq.StatementBuilderType
}

func New(db *sql.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                db: db,
                qb: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
        }
}</span>

type Stats struct {
        TotalClicks    int64
        UniqueVisitors int64
        LastClickedAt  *time.Time
}

func (r *Repository) BatchInsertClicks(events []models.ClickEvent) error <span class="cov0" title="0">{
        if len(events) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">query := r.qb.Insert("clicks").
                Columns("short_code", "clicked_at", "ip_address", "user_agent", "referer", "country")

        for _, event := range events </span><span class="cov0" title="0">{
                query = query.Values(
                        event.ShortCode,
                        event.Timestamp,
                        event.IPAddress,
                        event.UserAgent,
                        event.Referer,
                        event.Country,
                )
        }</span>

        <span class="cov0" title="0">_, err := query.RunWith(r.db).Exec()
        return err</span>
}

func (r *Repository) UpdateStats(shortCode string) error <span class="cov0" title="0">{
        query := `
                INSERT INTO url_stats (short_code, total_clicks, unique_visitors, last_clicked_at, updated_at)
                VALUES ($1, 1, 1, NOW(), NOW())
                ON CONFLICT (short_code) 
                DO UPDATE SET 
                        total_clicks = url_stats.total_clicks + 1,
                        last_clicked_at = NOW(),
                        updated_at = NOW()
        `
        _, err := r.db.Exec(query, shortCode)
        return err
}</span>

func (r *Repository) GetStats(shortCode string) (*Stats, error) <span class="cov0" title="0">{
        query := r.qb.Select("total_clicks", "unique_visitors", "last_clicked_at").
                From("url_stats").
                Where(sq.Eq{"short_code": shortCode})

        var stats Stats
        err := query.RunWith(r.db).QueryRow().Scan(
                &amp;stats.TotalClicks,
                &amp;stats.UniqueVisitors,
                &amp;stats.LastClickedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return &amp;Stats{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;stats, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package service

import (
        "context"
        "time"

        "url-shortener/services/analytics-service/models"
        "url-shortener/services/analytics-service/repository"
        "url-shortener/services/analytics-service/worker"

        pb "url-shortener/proto/generated/analytics_service"
)

type Service struct {
        pb.UnimplementedAnalyticsServiceServer
        pool *worker.WorkerPool
        repo *repository.Repository
}

func New(pool *worker.WorkerPool, repo *repository.Repository) *Service <span class="cov0" title="0">{
        return &amp;Service{
                pool: pool,
                repo: repo,
        }
}</span>

func (s *Service) RecordClick(ctx context.Context, req *pb.ClickEvent) (*pb.ClickResponse, error) <span class="cov0" title="0">{
        event := models.ClickEvent{
                ShortCode: req.ShortCode,
                IPAddress: req.IpAddress,
                UserAgent: req.UserAgent,
                Referer:   req.Referer,
                Country:   req.Country,
                Timestamp: time.Now(),
        }

        s.pool.Submit(event)

        return &amp;pb.ClickResponse{Success: true}, nil
}</span>

func (s *Service) GetStatistics(ctx context.Context, req *pb.StatsRequest) (*pb.StatsResponse, error) <span class="cov0" title="0">{
        stats, err := s.repo.GetStats(req.ShortCode)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var lastClicked string
        if stats.LastClickedAt != nil </span><span class="cov0" title="0">{
                lastClicked = stats.LastClickedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return &amp;pb.StatsResponse{
                TotalClicks:    stats.TotalClicks,
                UniqueVisitors: stats.UniqueVisitors,
                LastClickedAt:  lastClicked,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package worker

import (
        "log"
        "sync"
        "time"
        "url-shortener/services/analytics-service/models"
)

type WorkerPool struct {
        workers    int
        jobQueue   chan models.ClickEvent
        batchQueue chan []models.ClickEvent
        repo       Repository
        wg         sync.WaitGroup
        quit       chan struct{}
}

type Repository interface {
        BatchInsertClicks(events []models.ClickEvent) error
        UpdateStats(shortCode string) error
}

func New(workers, queueSize int, repo Repository) *WorkerPool <span class="cov2" title="2">{
        return &amp;WorkerPool{
                workers:    workers,
                jobQueue:   make(chan models.ClickEvent, queueSize),
                batchQueue: make(chan []models.ClickEvent, 100),
                repo:       repo,
                quit:       make(chan struct{}),
        }
}</span>

//        .
func (p *WorkerPool) Start() <span class="cov1" title="1">{
        // 1)  ,       .
        for i := 0; i &lt; p.workers; i++ </span><span class="cov2" title="2">{
                p.wg.Add(1)
                go p.worker(i + 1)
        }</span>

        // 2)  ,     .
        <span class="cov1" title="1">p.wg.Add(1)
        go p.batchCollector()</span>
}

func (p *WorkerPool) Submit(event models.ClickEvent) <span class="cov9" title="151">{
        select </span>{
        case p.jobQueue &lt;- event:<span class="cov9" title="151"></span>
        default:<span class="cov0" title="0">
                log.Println("Queue full, dropping event")</span>
        }
}

func (p *WorkerPool) worker(id int) <span class="cov2" title="2">{
        defer p.wg.Done()

        for batch := range p.batchQueue </span><span class="cov2" title="2">{
                if err := p.repo.BatchInsertClicks(batch); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Worker %d failed to insert batch: %v", id, err)
                }</span>

                <span class="cov2" title="2">for _, event := range batch </span><span class="cov9" title="150">{
                        if err := p.repo.UpdateStats(event.ShortCode); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Worker %d failed to update stats: %v", id, err)
                        }</span>
                }
        }
}

//    jobQueue      batchQueue.
func (p *WorkerPool) batchCollector() <span class="cov1" title="1">{
        defer p.wg.Done()

        const (
                maxBatchSize  = 100
                flushInterval = 1 * time.Second
        )

        batch := make([]models.ClickEvent, 0, maxBatchSize)
        timer := time.NewTimer(flushInterval)
        defer timer.Stop()

        flush := func() </span><span class="cov3" title="4">{
                if len(batch) == 0 </span><span class="cov2" title="2">{
                        return
                }</span>
                //  ,        .
                <span class="cov2" title="2">batchCopy := make([]models.ClickEvent, len(batch))
                copy(batchCopy, batch)
                select </span>{
                case p.batchQueue &lt;- batchCopy:<span class="cov2" title="2"></span>
                default:<span class="cov0" title="0">
                        log.Println("batchQueue full, dropping batch")</span>
                }
                <span class="cov2" title="2">batch = batch[:0]</span>
        }

        <span class="cov1" title="1">for </span><span class="cov10" title="153">{
                select </span>{
                case &lt;-p.quit:<span class="cov1" title="1">
                        //   .
                        flush()
                        close(p.batchQueue)
                        return</span>

                case ev := &lt;-p.jobQueue:<span class="cov9" title="150">
                        batch = append(batch, ev)
                        if len(batch) &gt;= maxBatchSize </span><span class="cov1" title="1">{
                                flush()
                                if !timer.Stop() </span><span class="cov0" title="0">{
                                        &lt;-timer.C
                                }</span>
                                <span class="cov1" title="1">timer.Reset(flushInterval)</span>
                        }

                case &lt;-timer.C:<span class="cov2" title="2">
                        flush()
                        timer.Reset(flushInterval)</span>
                }
        }
}

func (p *WorkerPool) Stop() <span class="cov1" title="1">{
        close(p.quit)
        p.wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "context"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"

        analyticsProto "url-shortener/proto/generated/analytics_service"
        cacheProto "url-shortener/proto/generated/cache_service"
        urlProto "url-shortener/proto/generated/url_service"
)

type Handler struct {
        urlClient       urlProto.URLServiceClient
        analyticsClient analyticsProto.AnalyticsServiceClient
        cacheClient     cacheProto.CacheServiceClient
}

func New(urlClient urlProto.URLServiceClient, analyticsClient analyticsProto.AnalyticsServiceClient, cacheClient cacheProto.CacheServiceClient) *Handler <span class="cov0" title="0">{
        return &amp;Handler{
                urlClient:       urlClient,
                analyticsClient: analyticsClient,
                cacheClient:     cacheClient,
        }
}</span>

type ShortenRequest struct {
        URL           string `json:"url" binding:"required,url"`
        UserID        string `json:"user_id"`
        ExpiresInDays int64  `json:"expires_in_days"`
}

func (h *Handler) ShortenURL(c *gin.Context) <span class="cov0" title="0">{
        var req ShortenRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        resp, err := h.urlClient.CreateShortURL(ctx, &amp;urlProto.CreateURLRequest{
                OriginalUrl:   req.URL,
                UserId:        req.UserID,
                ExpiresInDays: req.ExpiresInDays,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": resp.Error})
                return
        }</span>

        <span class="cov0" title="0">_, _ = h.cacheClient.Set(ctx, &amp;cacheProto.CacheSetRequest{
                Key:        resp.ShortCode,
                Value:      req.URL,
                TtlSeconds: 3600,
        })

        c.JSON(http.StatusOK, gin.H{
                "short_code": resp.ShortCode,
                "short_url":  resp.ShortUrl,
        })</span>
}

func (h *Handler) RedirectURL(c *gin.Context) <span class="cov0" title="0">{
        shortCode := c.Param("shortCode")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        cacheResp, _ := h.cacheClient.Get(ctx, &amp;cacheProto.CacheGetRequest{Key: shortCode})
        if cacheResp != nil &amp;&amp; cacheResp.Found </span><span class="cov0" title="0">{
                go h.recordClick(shortCode, c)
                c.Redirect(http.StatusMovedPermanently, cacheResp.Value)
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.urlClient.GetOriginalURL(ctx, &amp;urlProto.GetURLRequest{ShortCode: shortCode})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if !resp.Found </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": "URL not found"})
                return
        }</span>

        <span class="cov0" title="0">if !resp.IsActive </span><span class="cov0" title="0">{
                c.JSON(http.StatusGone, gin.H{"error": "URL has expired"})
                return
        }</span>

        <span class="cov0" title="0">h.cacheClient.Set(ctx, &amp;cacheProto.CacheSetRequest{
                Key:        shortCode,
                Value:      resp.OriginalUrl,
                TtlSeconds: 3600,
        })

        go h.recordClick(shortCode, c)

        c.Redirect(http.StatusMovedPermanently, resp.OriginalUrl)</span>
}

func (h *Handler) GetStats(c *gin.Context) <span class="cov0" title="0">{
        shortCode := c.Param("shortCode")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        resp, err := h.analyticsClient.GetStatistics(ctx, &amp;analyticsProto.StatsRequest{
                ShortCode: shortCode,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "short_code":      shortCode,
                "total_clicks":    resp.TotalClicks,
                "unique_visitors": resp.UniqueVisitors,
                "last_clicked_at": resp.LastClickedAt,
        })</span>
}

func (h *Handler) DeleteURL(c *gin.Context) <span class="cov0" title="0">{
        shortCode := c.Param("shortCode")

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        resp, err := h.urlClient.DeleteURL(ctx, &amp;urlProto.DeleteURLRequest{ShortCode: shortCode})
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">h.cacheClient.Delete(ctx, &amp;cacheProto.CacheDeleteRequest{Key: shortCode})

        c.JSON(http.StatusOK, gin.H{"success": resp.Success})</span>
}

func (h *Handler) recordClick(shortCode string, c *gin.Context) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        h.analyticsClient.RecordClick(ctx, &amp;analyticsProto.ClickEvent{
                ShortCode: shortCode,
                IpAddress: c.ClientIP(),
                UserAgent: c.Request.UserAgent(),
                Referer:   c.Request.Referer(),
                Country:   "",
        })
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package main

import (
        "context"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
        "url-shortener/services/api-gateway/handlers"
        "url-shortener/services/api-gateway/middleware"

        "github.com/gin-gonic/gin"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        analyticsProto "url-shortener/proto/generated/analytics_service"
        cacheProto "url-shortener/proto/generated/cache_service"
        urlProto "url-shortener/proto/generated/url_service"
)

func main() <span class="cov0" title="0">{
        urlConn, err := grpc.Dial(
                getEnv("URL_SERVICE_ADDR", "localhost:50051"),
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to URL service: %v", err)
        }</span>
        <span class="cov0" title="0">defer urlConn.Close()

        analyticsConn, err := grpc.Dial(
                getEnv("ANALYTICS_SERVICE_ADDR", "localhost:50052"),
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to Analytics service: %v", err)
        }</span>
        <span class="cov0" title="0">defer analyticsConn.Close()

        cacheConn, err := grpc.Dial(
                getEnv("CACHE_SERVICE_ADDR", "localhost:50053"),
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to Cache service: %v", err)
        }</span>
        <span class="cov0" title="0">defer cacheConn.Close()

        urlClient := urlProto.NewURLServiceClient(urlConn)
        analyticsClient := analyticsProto.NewAnalyticsServiceClient(analyticsConn)
        cacheClient := cacheProto.NewCacheServiceClient(cacheConn)

        h := handlers.New(urlClient, analyticsClient, cacheClient)

        r := gin.Default()

        rateLimiter := middleware.NewRateLimiter(10000, time.Minute)
        r.Use(rateLimiter.Middleware())

        r.POST("/shorten", h.ShortenURL)
        r.GET("/:shortCode", h.RedirectURL)
        r.GET("/stats/:shortCode", h.GetStats)
        r.DELETE("/:shortCode", h.DeleteURL)

        srv := &amp;http.Server{
                Addr:    ":8080",
                Handler: r,
        }

        go func() </span><span class="cov0" title="0">{
                log.Println("API Gateway listening on :8080")
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to start server: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("Shutting down API Gateway...")
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server forced to shutdown:", err)
        }</span>
}

func getEnv(key, fallback string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return fallback</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "url-shortener/pkg/ratelimit"
)

type RateLimiter struct {
        limiter *ratelimit.Limiter
}

func NewRateLimiter(rate int, per time.Duration) *RateLimiter <span class="cov0" title="0">{
        return &amp;RateLimiter{
                limiter: ratelimit.New(rate, per),
        }
}</span>

func (rl *RateLimiter) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                ip := c.ClientIP()

                if !rl.limiter.Allow(ip) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "rate limit exceeded",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cache

import (
        "context"
        "sync"
        "time"

        "github.com/go-redis/redis/v8"
)

type Cache struct {
        rdb      *redis.Client
        localMu  sync.RWMutex
        localMap map[string]cacheEntry
}

type cacheEntry struct {
        value     string
        expiresAt time.Time
}

func New(rdb *redis.Client) *Cache <span class="cov8" title="5">{
        c := &amp;Cache{
                rdb:      rdb,
                localMap: make(map[string]cacheEntry),
        }

        go c.cleanup()
        return c
}</span>

func (c *Cache) Get(ctx context.Context, key string) (string, bool, error) <span class="cov10" title="7">{
        c.localMu.RLock()
        if entry, ok := c.localMap[key]; ok </span><span class="cov8" title="5">{
                if time.Now().Before(entry.expiresAt) </span><span class="cov7" title="4">{
                        c.localMu.RUnlock()
                        return entry.value, true, nil
                }</span>
        }
        <span class="cov6" title="3">c.localMu.RUnlock()

        val, err := c.rdb.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov6" title="3">{
                return "", false, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">c.localMu.Lock()
        c.localMap[key] = cacheEntry{
                value:     val,
                expiresAt: time.Now().Add(5 * time.Minute),
        }
        c.localMu.Unlock()

        return val, true, nil</span>
}

func (c *Cache) Set(ctx context.Context, key, value string, ttl time.Duration) error <span class="cov7" title="4">{
        if err := c.rdb.Set(ctx, key, value, ttl).Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov7" title="4">c.localMu.Lock()
        c.localMap[key] = cacheEntry{
                value:     value,
                expiresAt: time.Now().Add(ttl),
        }
        c.localMu.Unlock()

        return nil</span>
}

func (c *Cache) Delete(ctx context.Context, key string) error <span class="cov1" title="1">{
        c.localMu.Lock()
        delete(c.localMap, key)
        c.localMu.Unlock()

        return c.rdb.Del(ctx, key).Err()
}</span>

func (c *Cache) cleanup() <span class="cov8" title="5">{
        ticker := time.NewTicker(time.Minute)
        defer ticker.Stop()

        for range ticker.C </span><span class="cov0" title="0">{
                c.localMu.Lock()
                now := time.Now()
                for key, entry := range c.localMap </span><span class="cov0" title="0">{
                        if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                                delete(c.localMap, key)
                        }</span>
                }
                <span class="cov0" title="0">c.localMu.Unlock()</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"

        "url-shortener/services/cache-service/cache"
        "url-shortener/services/cache-service/service"

        "github.com/go-redis/redis/v8"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        pb "url-shortener/proto/generated/cache_service"
)

func main() <span class="cov0" title="0">{
        redisAddr := os.Getenv("REDIS_ADDR")
        if redisAddr == "" </span><span class="cov0" title="0">{
                redisAddr = "localhost:6379"
        }</span>

        <span class="cov0" title="0">rdb := redis.NewClient(&amp;redis.Options{
                Addr:     redisAddr,
                PoolSize: 10,
        })

        cacheManager := cache.New(rdb)
        svc := service.New(cacheManager)

        lis, err := net.Listen("tcp", ":50053")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        pb.RegisterCacheServiceServer(grpcServer, svc)
        reflection.Register(grpcServer)

        go func() </span><span class="cov0" title="0">{
                log.Println("Cache Service listening on :50053")
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to serve: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("Shutting down Cache Service...")
        grpcServer.GracefulStop()
        rdb.Close()</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "context"
        "time"
        "url-shortener/services/cache-service/cache"

        pb "url-shortener/proto/generated/cache_service"
)

type Service struct {
        pb.UnimplementedCacheServiceServer
        cache *cache.Cache
}

func New(cache *cache.Cache) *Service <span class="cov0" title="0">{
        return &amp;Service{cache: cache}
}</span>

func (s *Service) Get(ctx context.Context, req *pb.CacheGetRequest) (*pb.CacheGetResponse, error) <span class="cov0" title="0">{
        value, found, err := s.cache.Get(ctx, req.Key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;pb.CacheGetResponse{
                Value: value,
                Found: found,
        }, nil</span>
}

func (s *Service) Set(ctx context.Context, req *pb.CacheSetRequest) (*pb.CacheSetResponse, error) <span class="cov0" title="0">{
        ttl := time.Duration(req.TtlSeconds) * time.Second
        if ttl == 0 </span><span class="cov0" title="0">{
                ttl = 24 * time.Hour
        }</span>

        <span class="cov0" title="0">err := s.cache.Set(ctx, req.Key, req.Value, ttl)
        return &amp;pb.CacheSetResponse{Success: err == nil}, err</span>
}

func (s *Service) Delete(ctx context.Context, req *pb.CacheDeleteRequest) (*pb.CacheDeleteResponse, error) <span class="cov0" title="0">{
        err := s.cache.Delete(ctx, req.Key)
        return &amp;pb.CacheDeleteResponse{Success: err == nil}, err
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "database/sql"
        "log"
        "net"
        "os"
        "os/signal"
        "syscall"

        "url-shortener/services/url-service/repository"
        "url-shortener/services/url-service/service"

        _ "github.com/lib/pq"
        "google.golang.org/grpc"
        "google.golang.org/grpc/reflection"

        pb "url-shortener/proto/generated/url_service"
)

func main() <span class="cov0" title="0">{
        dbURL := os.Getenv("DATABASE_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                log.Fatal("DATABASE_URL not set")
        }</span>

        <span class="cov0" title="0">db, err := sql.Open("postgres", dbURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)

        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to ping database: %v", err)
        }</span>

        <span class="cov0" title="0">repo := repository.New(db)
        svc := service.New(repo)

        lis, err := net.Listen("tcp", ":50051")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        pb.RegisterURLServiceServer(grpcServer, svc)
        reflection.Register(grpcServer)

        go func() </span><span class="cov0" title="0">{
                log.Println("URL Service listening on :50051")
                if err := grpcServer.Serve(lis); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to serve: %v", err)
                }</span>
        }()

        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        log.Println("Shutting down URL Service...")
        grpcServer.GracefulStop()</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "database/sql"
        "time"

        sq "github.com/Masterminds/squirrel"
)

type Repository struct {
        db *sql.DB
        qb sq.StatementBuilderType
}

func New(db *sql.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                db: db,
                qb: sq.StatementBuilder.PlaceholderFormat(sq.Dollar),
        }
}</span>

type URL struct {
        ID          int64
        ShortCode   string
        OriginalURL string
        CreatedAt   time.Time
        ExpiresAt   *time.Time
        UserID      string
        IsActive    bool
}

func (r *Repository) Create(url *URL) error <span class="cov0" title="0">{
        query := r.qb.Insert("urls").
                Columns("short_code", "original_url", "user_id", "expires_at", "is_active").
                Values(url.ShortCode, url.OriginalURL, url.UserID, url.ExpiresAt, url.IsActive).
                Suffix("RETURNING id, created_at")

        return query.RunWith(r.db).QueryRow().Scan(&amp;url.ID, &amp;url.CreatedAt)
}</span>

func (r *Repository) GetByShortCode(shortCode string) (*URL, error) <span class="cov0" title="0">{
        query := r.qb.Select("id", "short_code", "original_url", "created_at", "expires_at", "user_id", "is_active").
                From("urls").
                Where(sq.Eq{"short_code": shortCode})

        var url URL
        err := query.RunWith(r.db).QueryRow().Scan(
                &amp;url.ID, &amp;url.ShortCode, &amp;url.OriginalURL, &amp;url.CreatedAt,
                &amp;url.ExpiresAt, &amp;url.UserID, &amp;url.IsActive,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;url, nil</span>
}

func (r *Repository) Delete(shortCode string) error <span class="cov0" title="0">{
        query := r.qb.Update("urls").
                Set("is_active", false).
                Where(sq.Eq{"short_code": shortCode})

        _, err := query.RunWith(r.db).Exec()
        return err
}</span>

func (r *Repository) Exists(shortCode string) (bool, error) <span class="cov0" title="0">{
        query := r.qb.Select("COUNT(*)").
                From("urls").
                Where(sq.Eq{"short_code": shortCode})

        var count int
        err := query.RunWith(r.db).QueryRow().Scan(&amp;count)
        return count &gt; 0, err
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package service

import (
        "context"
        "database/sql"
        "time"

        "url-shortener/pkg/shortcode"
        "url-shortener/services/url-service/repository"

        pb "url-shortener/proto/generated/url_service"
)

type Service struct {
        pb.UnimplementedURLServiceServer
        repo *repository.Repository
}

func New(repo *repository.Repository) *Service <span class="cov0" title="0">{
        return &amp;Service{repo: repo}
}</span>

func (s *Service) CreateShortURL(ctx context.Context, req *pb.CreateURLRequest) (*pb.CreateURLResponse, error) <span class="cov0" title="0">{
        var expiresAt *time.Time
        if req.ExpiresInDays &gt; 0 </span><span class="cov0" title="0">{
                t := time.Now().AddDate(0, 0, int(req.ExpiresInDays))
                expiresAt = &amp;t
        }</span>

        <span class="cov0" title="0">var code string
        var err error

        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                code, err = shortcode.Generate()
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;pb.CreateURLResponse{Success: false, Error: "failed to generate code"}, nil
                }</span>

                <span class="cov0" title="0">exists, _ := s.repo.Exists(code)
                if !exists </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">url := &amp;repository.URL{
                ShortCode:   code,
                OriginalURL: req.OriginalUrl,
                UserID:      req.UserId,
                ExpiresAt:   expiresAt,
                IsActive:    true,
        }

        if err := s.repo.Create(url); err != nil </span><span class="cov0" title="0">{
                return &amp;pb.CreateURLResponse{Success: false, Error: err.Error()}, nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.CreateURLResponse{
                ShortCode: code,
                ShortUrl:  "http://localhost:8080/" + code,
                Success:   true,
        }, nil</span>
}

func (s *Service) GetOriginalURL(ctx context.Context, req *pb.GetURLRequest) (*pb.GetURLResponse, error) <span class="cov0" title="0">{
        url, err := s.repo.GetByShortCode(req.ShortCode)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return &amp;pb.GetURLResponse{Found: false}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if url.ExpiresAt != nil &amp;&amp; time.Now().After(*url.ExpiresAt) </span><span class="cov0" title="0">{
                return &amp;pb.GetURLResponse{Found: true, IsActive: false}, nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.GetURLResponse{
                OriginalUrl: url.OriginalURL,
                Found:       true,
                IsActive:    url.IsActive,
        }, nil</span>
}

func (s *Service) DeleteURL(ctx context.Context, req *pb.DeleteURLRequest) (*pb.DeleteURLResponse, error) <span class="cov0" title="0">{
        err := s.repo.Delete(req.ShortCode)
        return &amp;pb.DeleteURLResponse{Success: err == nil}, err
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
